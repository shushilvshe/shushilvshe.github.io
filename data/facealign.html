
<!DOCTYPE html>
<html lang="zh_cn">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://www.shushilvshe.com/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://www.shushilvshe.com/theme/pygments/monokai.min.css">
  <link rel="stylesheet" type="text/css" href="http://www.shushilvshe.com/theme/font-awesome/css/font-awesome.min.css">




    <link rel="shortcut icon" href="http://www.shushilvshe.com/images/lvcheng.jpg" type="image/x-icon">
    <link rel="icon" href="http://www.shushilvshe.com/images/lvcheng.jpg" type="image/x-icon">

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />


<meta name="author" content="ssls" />
<meta name="description" content="使用facenet框架，可以识别出一张图片中的人脸头像，并返回每张人脸的边界和五官坐标，但图片中有的头像是有倾斜角度的，我们将倾斜度数小于指定阈值的进行校正，其余的按原形截取图片。" />
<meta name="keywords" content="大数据, 机器学习, 人脸识别, 人脸对齐">

<meta property="og:site_name" content="shushilvshe's Blog"/>
<meta property="og:title" content="人脸识别——对齐算法"/>
<meta property="og:description" content="使用facenet框架，可以识别出一张图片中的人脸头像，并返回每张人脸的边界和五官坐标，但图片中有的头像是有倾斜角度的，我们将倾斜度数小于指定阈值的进行校正，其余的按原形截取图片。"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://www.shushilvshe.com/data/facealign.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-09-05 22:24:46+08:00"/>
<meta property="article:modified_time" content="2017-09-05 22:24:49+08:00"/>
<meta property="article:author" content="http://www.shushilvshe.com/author/ssls.html">
<meta property="article:section" content="Data"/>
<meta property="article:tag" content="大数据"/>
<meta property="article:tag" content="机器学习"/>
<meta property="article:tag" content="人脸识别"/>
<meta property="article:tag" content="人脸对齐"/>
<meta property="og:image" content="http://www.shushilvshe.com/images/baya.jpg">

  <title>shushilvshe's Blog &ndash; 人脸识别——对齐算法</title>

</head>
<body>
  <aside>
    <div>
      <a href="http://www.shushilvshe.com">
        <img src="http://www.shushilvshe.com/images/baya.jpg" alt="数食旅摄" title="数食旅摄">
      </a>
      <h1><a href="http://www.shushilvshe.com">数食旅摄</a></h1>

<p>Data Developer</p>
      <nav>
        <ul class="list">
          <li><a href="http://www.shushilvshe.com/pages/about.html#about">About ME</a></li>

          <li><a href="/categories.html" target="_blank">Category</a></li>
          <li><a href="/tags.html" target="_blank">Tags</a></li>
          <li><a href="/archives.html" target="_blank">Archives</a></li>
        </ul>
      </nav>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href="http://www.shushilvshe.com">    Home
</a>

      <a href="/category/data.html">Data</a>
      <a href="/category/food.html">Food</a>
      <a href="/category/travel.html">Travel</a>
      <a href="/">Photo</a>


    </nav>

<article class="single">
  <header>
      
    <h1 id="data/facealign">人脸识别——对齐算法</h1>
    <p>
          Posted on 2017-09-05(星期二) 22:24 in <a href="http://www.shushilvshe.com/category/data.html">Data</a>


    </p>
  </header>


  <div>
    <p><strong>基本思路：</strong></p>
<p>使用facenet框架，可以识别出一张图片中的人脸头像，并返回每张人脸的边界和五官坐标，但图片中有的头像是有倾斜角度的，我们将倾斜度数小于指定阈值的进行校正，其余的按原形截取图片。</p>
<ul>
<li>倾斜度数根据两只眼睛的坐标加以计算；</li>
<li>缩放比为两眼X坐标与两眼之间的距离比值；</li>
<li>将人脸边界大小分别向四个方向扩充对应边的1/4长，也就是两边界长宽扩为1.5倍/缩放比；</li>
<li>截取扩充的区域，然后以鼻子坐标为中心进行旋转（也可以考虑以左眼为中心旋转，但以有效数据的中点进行旋转可降低扩充的面积）；</li>
<li>旋转后鼻子的X、Y坐标为原坐标减左边界和上边界；</li>
<li>旋转后需要根据两眼和鼻子构成的三角形算出旋转后左眼的坐标，用于最后截图中心点的定位（根据余弦定理和勾股定理计算）；</li>
<li>根据两眼的斜率和人脸边界大概可以计算两眼连线之上有效高度，用于确定最后图片上边界（默认认为脸长大于脸宽）；</li>
<li>脸的长度根据人脸边界/斜率得出大概值（偏小）；</li>
<li>总的图片高度根据计算出的脸长和margin值相加得来；</li>
<li>根据左眼坐标和图片高度计算最后截图需要的四个边界值，得到最后需要图，最后进行缩放完成。</li>
</ul>
<p>算法实现：</p>
<div class="highlight"><pre><span></span>def alignFace(self, image, boundingBoxes, positions, cropSize=160, angleThreshold=5):
    &#39;&#39;&#39;
image 原始图像
boundingBoxes 脸部轮廓边框
positions 五官坐标
cropSize：最后保留的图像的大小 
angleThreshold: 旋转头像倾斜角度阈值
    &#39;&#39;&#39;
    aligneds=[]
    if len(positions.shape) &lt; 2:
        return aligneds
    for i in range(positions.shape[1]):
        eyeLeft, eyeRight=(positions[0,i], positions[5,i]), (positions[1,i], positions[6,i])
        nosePoint = (positions[2,i], positions[7,i])
        eye_direction = (eyeRight[0]- eyeLeft[0], eyeRight[1]- eyeLeft[1])  
        eyeDist = self.__distance(eyeLeft, eyeRight)
        leftEyeNoseDist = self.__distance(eyeLeft, nosePoint)
        rightEyeNoseDist = self.__distance(nosePoint, eyeRight)
        slope = math.fabs(eye_direction[1]/eye_direction[0])
        rate = math.fabs(eye_direction[0]/eyeDist)

        #图片倾斜度超过阈值时旋转
        if slope &gt;= math.tan(angleThreshold*math.pi/180):
            #根据boundingBox和斜度截取小图
            boxWidth,boxHeight = (boundingBoxes[i,2]-boundingBoxes[i,0]),(boundingBoxes[i,3]-boundingBoxes[i,1])
            left,upper = (boundingBoxes[i,0]-boxWidth/4/rate),(boundingBoxes[i,1]-boxHeight/4/rate)
            right,lower = (boundingBoxes[i,2]+boxWidth/4/rate),(boundingBoxes[i,3]+boxHeight/4/rate)
            img = Image.fromarray(image).crop((left, upper, right, lower))
            img.save(&#39;D:/test_data/face/crop&#39; +str(i)+ &#39;.jpg&#39;)

            #以鼻子为中心旋转截图
            nosePoint = ((nosePoint[0]-left), (nosePoint[1]-upper))
            rotation = -math.atan2(float(eye_direction[1]),float(eye_direction[0]))
            img = self.__scaleRotateTranslate(img, center=nosePoint, angle=rotation) 
            img.save(&#39;D:/test_data/face/rotate&#39; +str(i)+ &#39;.jpg&#39;)

            #计算旋转之后左眼坐标
            cosLeftEye = math.fabs((math.pow(eyeDist,2)+math.pow(leftEyeNoseDist,2)-math.pow(rightEyeNoseDist,2))/(2*eyeDist*leftEyeNoseDist))
            rotatedLfEye = ((nosePoint[0]-leftEyeNoseDist*cosLeftEye), (nosePoint[1]-math.sqrt(math.pow(leftEyeNoseDist,2)-math.pow(leftEyeNoseDist*cosLeftEye,2))))

            #截取正面脸部图像
            faceLen = (int(math.fabs(boundingBoxes[i,1]-boundingBoxes[i,3])))/rate
            margin = ((boxWidth+boxHeight)//60)*math.pow(rate,3)
            finalLen = faceLen+2*margin
            upEyeHeight = self.__getUpEyeHeight(eyeLeft, eyeRight, eyeDist, boundingBoxes[i,1])
            left,upper = (rotatedLfEye[0]+eyeDist/2-finalLen/2), (rotatedLfEye[1]-upEyeHeight-margin)
            right,lower = left+finalLen, upper+finalLen
            img = img.crop((left, upper, right, lower))  
            img = img.resize((cropSize, cropSize), Image.ANTIALIAS)
            img.save(&#39;D:/test_data/face/duoren&#39; +str(i)+ &#39;.jpg&#39;)
            aligneds.append(np.array(img)) 
        else:#原图截图
            img_size = np.asarray(image.shape)[0:2]
            margin=self.__computerMargin(boundingBoxes[i])
            det = np.squeeze(boundingBoxes[i])
            bb = np.zeros(4, dtype=np.int32)
            bb[0] = np.maximum(det[0]-margin/2, 0)
            bb[1] = np.maximum(det[1]-margin/2, 0)
            bb[2] = np.minimum(det[2]+margin/2, img_size[1])
            bb[3] = np.minimum(det[3]+margin/2, img_size[0])
            cropped = image[bb[1]:bb[3],bb[0]:bb[2],:]
            aligned = misc.imresize(cropped, (cropSize, cropSize), interp=&#39;bilinear&#39;)
            aligneds.append(aligned)
    return aligneds
</pre></div>


<p>最后效果如下：</p>
<p><strong>原图：</strong>
<center><img src="/images/data-facealign/lixiaoliyuan.jpg" width="640"/></center></p>
<p><strong>对齐：</strong>
<center><img src="/images/data-facealign/lixiaoli.jpg" width="163"/></center></p>
<hr>
<p><strong>原图：</strong>
<center><img src="/images/data-facealign/renlian11.jpg" width="640"/></center></p>
<p><strong>对齐：</strong>
<center><img src="/images/data-facealign/renlian1.jpg" width="163"/></center></p>
<hr>
<p><strong>原图：</strong>
<center><img src="/images/data-facealign/renlian22.jpg" width="640"/></center></p>
<p><strong>对齐：</strong>
<center><img src="/images/data-facealign/renlian2.jpg" width="163"/></center></p>
<h2>总结：</h2>
<p>该算法取图片长度的算法取决于facenet返回的人脸边界和脸的斜率，在斜率不是太高（40度以下）的时候表现还好。</p>
<p><strong>改进：</strong></p>
<ul>
<li>随着斜率增大，图片下方，也就是下巴下部空闲部分会多一些；</li>
<li>脸旁两部分无用数据较多，如果是贴脸照片会多出干扰信息，这个也可根据人脸边界进行改进修正。</li>
</ul>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://www.shushilvshe.com/tag/da-shu-ju.html">大数据</a>
      <a href="http://www.shushilvshe.com/tag/ji-qi-xue-xi.html">机器学习</a>
      <a href="http://www.shushilvshe.com/tag/ren-lian-shi-bie.html">人脸识别</a>
      <a href="http://www.shushilvshe.com/tag/ren-lian-dui-qi.html">人脸对齐</a>
    </p>
  </div>



    <div class="addthis_relatedposts_inline">


</article>

    <footer>
<p>&copy;  </p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " shushilvshe's Blog ",
  "url" : "http://www.shushilvshe.com",
  "image": "http://www.shushilvshe.com/images/baya.jpg",
  "description": "shushilvshe's Thoughts and Writings"
}
</script>

</body>
</html>